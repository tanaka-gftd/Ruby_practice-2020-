#ブロックについて


#ブロックを渡すメソッド呼び出し


#配列へ処理を繰り返す際に、ブロックを使う（復習）
#doからendまでがブロック
drinks = ["コーヒー", "カフェラテ"]
drinks.each do |drink|   #eachメソッドにブロック（do~end）を渡す
    puts drink
end

=begin

ブロックはプログラムの塊をメソッドへと渡すことが出来る仕組み
渡されたブロックは、呼び出したメソッドの処理の中で出番が来ると実行される
渡せるブロックは１つだけ
ブロックを受け取るメソッドの中には、ブロックを渡した時と渡さない時のどちらでも動作するものがある

=end


#渡されたブロックを実行する

#block_given?メソッド・・・ブロックを渡されたかどうかを判別するメソッド
#block_given?メソッドの使用例
def foo
    p block_given?
end

foo   #ブロックを渡していないのでfalseを返す

foo do   #ブロックを渡しているのでtrueを返す（何も書かなくてもブロックは渡せる）
end



#渡したブロックを実行してみる・・・yieldメソッド
#サイコロを振るプログラムでのyieldメソッド使用例
#if と block_given? で条件分岐
def dice
    if block_given?   #ブロックが渡されたか判定

        #ブロックが渡されたときの処理
        puts "run block"
        yield   #渡されたブロックを実行
    else

        #ブロックが渡されなかった時の処理
        puts "normal dice"
        puts [1, 2, 3, 4, 5, 6].sample
    end
end

#ブロックを渡さない時
dice   #１から６までの中の１つをランダムで表示する

#ブロックを渡す時
dice do
    puts [4, 5, 6].sample   #４から６までの中の１つをランダムで表示する 
end



#ブロック（プログラムをまとめたもの）は変数に代入できる
#この時、ブロックはProcというオブジェクトとして扱われている
#渡されたブロックは引数で受け取れる
#ブロックを受け取る引数には先頭に&を追加する
#変数に代入されたブロックは、callメソッドで実行する（callメソッドは、ブロックの処理を実行する）
#例
def foo(&b)   #引数bは先頭に&がついているので、ブロックを受け取って実行される
    b.call   #callメソッドで渡されたブロックを実行する
    p b.class   #Proc ・・・ブロックのクラスが表示される
end

foo do 
    puts "Chunky bacon!!"   #"Chunky bacon!!" と表示する
end
